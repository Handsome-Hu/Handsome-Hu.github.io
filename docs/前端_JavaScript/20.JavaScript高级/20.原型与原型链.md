---
title: 原型与原型链
date: 2022-02-17 10:32:27
permalink: /pages/449573/
categories:
  - JavaScript
  - JavaScript高级
tags:
  - JavaScript
---
# 原型与原型链

## 原型对象

### 构造函数原型`prototype`

Javascript 规定，**每一个构造函数都有一个 `prototype` 属性，指向另一个对象。 这个对象的所有属性和方法，都会被构造函数的实例继承**。

这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 `prototype` 对象上。

```javascript
function Person (name, age) {
  this.name = name
  this.age = age
}

Person.prototype.type = 'human'

Person.prototype.sayName = function () {
  console.log(this.name)
}

var p1 = new Person('张三', 25)
var p2 = new Person('李四', 40)

p1.sayName() // => 张三
p2.sayName() // => 李四

console.log(p1.type)  // => human
console.log(p1.sayName === p2.sayName) // => true
```

这时所有实例的 `type` 属性和 `sayName()` 方法， 其实都是同一个内存地址，指向 `prototype` 对象，因此就提高了运行效率。

### 对象原型`__proto__`

在上面的例子中，我们试着输出两个对象`p1`和`p2`，会发现它们有一个特别的属性**`__proto__`**。

下面我们用代码验证一下他和构造函数的原型对象`prototype` 的关系：

```javascript
console.log(Person.prototype === p1.__proto__) // => true
console.log(Person.prototype === p2.__proto__) // => true
console.log(p1.__proto__ === p2.__proto__) // => true
```

`p1.__proto__`和`Person.prototype`是完全相等的，我们可以用下面这张图来展示他们之间的关系：

![](https://blog-1259322452.cos.ap-guangzhou.myqcloud.com/java/20220217140223.png)

### `prototype`和`__proto__`的区别

事实上不仅是构造函数，任何函数都具有一个 `prototype` 属性，该属性是一个对象。而`__proto__`是每个对象都有的属性。

我们知道在 JavaScript 中，所有数据类型都可以视为对象，包括函数，因此函数不光有`prototype`属性，也有`__proto__`属性。

```javascript
var obj = {};
console.log(obj.prototype);  //undefined
console.log(obj.__proto__);  //Object {}

var F = function(){}
console.log(F.prototype);  //F {}
console.log(F.__proto__);  //function() {}
```

![image-20220217141100926](https://blog-1259322452.cos.ap-guangzhou.myqcloud.com/java/image-20220217141100926.png)

构造函数的 `prototype` 对象默认都有一个 `constructor` 属性，指向 `prototype` 对象所在函数。

```javascript
console.log(F.constructor === F) // => true
```

通过构造函数得到的实例对象内部会包含一个指向构造函数的 `prototype` 对象的指针 `__proto__`。

```javascript
var instance = new F()
console.log(instance.__proto__ === F.prototype) // => true
```

实例对象可以直接访问原型对象成员。

总结：

- 任何函数都具有一个 `prototype` 属性，该属性是一个对象
- 构造函数的 `prototype` 对象默认都有一个 `constructor` 属性，指向 `prototype` 对象所在函数
- 通过构造函数得到的实例对象内部会包含一个指向构造函数的 `prototype` 对象的指针 `__proto__`
- 所有实例都直接或间接继承了原型对象的成员

## 属性成员的搜索原则：原型链

### 什么是原型链？

由于`__proto__`是任何对象都具有的属性，大部分情况下，`__proto__`指向的是构造器的原型对象（Object.create是特殊情况），因此会形成一条`__proto__`连起来的链条，递归访问`__proto__`必须最终到头，并且值是`null`，这就形成了**原型链**。

![image-20220217145454598](https://blog-1259322452.cos.ap-guangzhou.myqcloud.com/java/image-20220217145454598.png)

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性

- 搜索首先从对象实例本身开始
- 如果在实例中找到了具有给定名字的属性，则返回该属性的值
- 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性
- 如果在原型对象中找到了这个属性，则返回该属性的值

也就是说，在最开始的例子中，我们调用 `person1.sayName()` 的时候，会先后执行两次搜索：

- 首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有”。
- 然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。”
- 于是，它就读取那个保存在原型对象中的函数。
- 当我们调用 person2.sayName() 时，将会重现相同的搜索过程，得到相同的结果。

而这正是多个对象实例共享原型所保存的属性和方法的基本原理。

总结：

- 先在自己身上找，找到即返回
- 自己身上找不到，则沿着原型链向上查找，找到即返回
- 如果一直到原型链的末端还没有找到，则返回 `undefined`

### 更简单的原型语法

我们注意到，前面例子中每添加一个属性和方法就要敲一遍 `Person.prototype` 。 为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：

```javascript
function Person (name, age) {
  this.name = name
  this.age = age
}

Person.prototype = {
  type: 'human',
  sayHello: function () {
    console.log('我叫' + this.name + '，我今年' + this.age + '岁了')
  }
}
```

在该示例中，我们将 `Person.prototype` 重置到了一个新的对象。 这样做的好处就是为 `Person.prototype` 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 `constructor` 成员。

所以，我们为了保持 `constructor` 的指向正确，建议的写法是：

```javascript
function Person (name, age) {
  this.name = name
  this.age = age
}

Person.prototype = {
  constructor: Person, // => 手动将 constructor 指向正确的构造函数
  type: 'human',
  sayHello: function () {
    console.log('我叫' + this.name + '，我今年' + this.age + '岁了')
  }
}
```

### 原型对象使用建议

- 私有成员（一般就是非函数成员）放到构造函数中
- 共享成员（一般就是函数）放到原型对象中
- 如果重置了 `prototype` 记得修正 `constructor` 的指向