---
title: 【ES6】函数的扩展
date: 2022-02-18 10:53:09
permalink: /pages/bbc099/
categories:
  - JavaScript
  - ECMAScript6
tags:
  - ECMAScript6
---
## 箭头函数

### 基本用法

ES6允许使用箭头（=>）定义函数，箭头函数提供了一种更加简洁的函数书写方式，箭头函数多用于匿
名函数的定义；

**箭头函数的注意点：**

1. 如果形参只有一个，则小括号可以省略；
2. 函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果；
3. 箭头函数 this 指向声明时所在作用域下 this 的值；
4. 箭头函数不能作为构造函数实例化；
5. 不能使用 arguments；

**特性：**

1. 箭头函数的this是静态的，始终指向函数声明时所在作用域下的this的值；
2. 不能作为构造实例化对象；
3. 不能使用 arguments 变量；

### 代码演示及相关说明

```javascript
// ES6允许使用箭头（=>）定义函数
// 传统写法：无参数
var say = function(){
	console.log("hello！");
}
say();
// ES写法2：无参数
let speak = () => console.log("hello 哈哈！");
speak();
// 传统写法：一个参数
var hello = function(name){
	return "hello " + name;
}
console.log(hello("阿凯"));
// ES6箭头函数：一个参数
let hi = name => "hi " + name;
console.log(hi("阿凯"));
// 传统写法：多个参数
var sum = function(a,b,c){
	return a + b + c;
}
console.log(sum(1,2,3));
// ES6箭头函数：多个参数
let he = (a,b,c) => a + b + c;
console.log(he(1,2,3));

// 特性
// 1、箭头函数的this是静态的，始终指向函数声明时所在作用域下的this的值
const school = {
	name : "大哥",
}
// 传统函数
function getName(){
	console.log("getName：" + this.name);
}
// 箭头函数
getName1 = () => console.log("getName1：" + this.name);
window.name = "阿凯";
// 直接调用
getName();
getName1();
// 使用call调用
getName.call(school);
getName1.call(school);
// 结论：箭头函数的this是静态的，始终指向函数声明时所在作用域下的this的值
// 2、不能作为构造实例化对象
// let Persion = (name,age) => {
// this.name = name;
// this.age = age;
// }
// let me = new Persion("訾博",24);
// console.log(me);
// 报错：Uncaught TypeError: Persion is not a constructor
// 3、不能使用 arguments 变量
// let fn = () => console.log(arguments);
// fn(1,2,3);
// 报错：Uncaught ReferenceError: arguments is not defined
```

运行结果：

![image-20220218132103697](https://blog-1259322452.cos.ap-guangzhou.myqcloud.com/java/image-20220218132103697.png)

### 箭头函数的实践和应用场景

#### 需求-1：点击 div 2s 后颜色变成『粉色』

**传统写法存在问题：**

```javascript
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>箭头函数的实践和应用场景</title>
    <style>
        div {
            width: 200px;
            height: 200px;
            background: #58a;
        }
    </style>
</head>

<body>
    <div id="ad"></div>
    <script>
        // 需求-1 点击 div 2s 后颜色变成『粉色』
        // 获取元素
        let ad = document.getElementById('ad');
        // 绑定事件
        ad.addEventListener("click", function () {
            // 传统写法
            // 定时器：参数1：回调函数；参数2：时间；
            setTimeout(function () {
                console.log(this);
                this.style.background = 'pink';
            }, 2000);
            // 报错Cannot set property 'background' of undefined
        });
    </script>
</body>

</html>
```

![image-20220218133933755](https://blog-1259322452.cos.ap-guangzhou.myqcloud.com/java/image-20220218133933755.png)

报错的原因是因为在setTimeout方法体内，this的指向已经发生改变，不再指向id为ad的DOM元素，而是指向顶层对象window。

<iframe height="300" style="width: 100%;" scrolling="no" title="点击 div 2s 后颜色变成『粉色』" src="https://codepen.io/handsome-hu/embed/RwjQPKq?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/handsome-hu/pen/RwjQPKq">
  点击 div 2s 后颜色变成『粉色』</a> by HuKai (<a href="https://codepen.io/handsome-hu">@handsome-hu</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

**ES6写法：**

<iframe height="300" style="width: 100%;" scrolling="no" title="点击 div 2s 后颜色变成『粉色』- ES6写法" src="https://codepen.io/handsome-hu/embed/jOaZPwb?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/handsome-hu/pen/jOaZPwb">
  点击 div 2s 后颜色变成『粉色』- ES6写法</a> by HuKai (<a href="https://codepen.io/handsome-hu">@handsome-hu</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

#### 需求-2 从数组中返回偶数的元素：

```javascript
//需求-2 从数组中返回偶数的元素
const arr = [1, 6, 9, 10, 100, 25];
// const result = arr.filter(function(item){
// if(item % 2 === 0){
// return true;
// }else{
// return false;
// }
// });
const result = arr.filter(item => item % 2 === 0);
console.log(result);// 输出 => [6,10.100]
```

### 总结

- 箭头函数适合与 this 无关的回调. 定时器, 数组的方法回调
- 箭头函数不适合与 this 有关的回调. 事件回调, 对象的方法

## ES6中函数参数的默认值

ES允许给函数的参数赋初始值；

### 代码示例及相关说明

```javascript
//ES6 允许给函数参数赋值初始值
//1. 形参初始值 具有默认值的参数, 一般位置要靠后(潜规则)
function add(a, b, c = 10) {
	return a + b + c;
}
let result = add(1, 2);
console.log(result); // 13
//2. 与解构赋值结合
// 注意这里参数是一个对象
function connect({ host = "127.0.0.1", username, password, port }) {
    console.log(host)
    console.log(username)
    console.log(password)
    console.log(port)
}
connect({
    host: 'atguigu.com',
    username: 'root',
    password: 'root',
    port: 3306
})
```

运行结果：

![image-20220218140319951](https://blog-1259322452.cos.ap-guangzhou.myqcloud.com/java/image-20220218140319951.png)

## rest参数

参考文章: https://www.jianshu.com/p/50bcb376a419

### 代码示例及相关说明

ES6 引入 `rest` 参数，用于获取函数的实参，用来代替 `arguments`；

```javascript
// ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments；
// ES5获取实参的方式
function data(){
	console.log(arguments);
}
data("大哥","二哥","三哥","四哥");
// ES6的rest参数...args，rest参数必须放在最后面
function data(...args){
	console.log(args); // fliter some every map
}
data("大哥","二哥","三哥","四哥");
```

### Rest参数和arguments对象的区别


- rest参数只包括那些没有给出名称的参数，arguments包含所有参数
- arguments 对象不是真正的数组，而rest 参数是数组实例，可以直接应用sort, map, forEach, pop等方法
- arguments 对象拥有一些自己额外的功能

## 扩展运算符

### 基本使用

`...`扩展运算符能将数组转换为逗号分隔的参数序列；

> 扩展运算符（spread）也是三个点（...）。**它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包；**

```javascript
// ... 扩展运算符能将数组转换为逗号分隔的参数序列
//声明一个数组 ...
const tfboys = ['易烊千玺', '王源', '王俊凯'];
// => '易烊千玺','王源','王俊凯'
// 声明一个函数
function chunwan() {
    console.log(arguments);
}
chunwan(...tfboys); // chunwan('易烊千玺','王源','王俊凯')
```

运行结果：

![image-20220218142127182](https://blog-1259322452.cos.ap-guangzhou.myqcloud.com/java/image-20220218142127182.png)

### 扩展运算符的应用

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>扩展运算符应用</title>
</head>
<body>
    <div id="d1"></div>
    <div id="d2"></div>
    <script>
        //1. 数组的合并 情圣 误杀 唐探
        const kuaizi = ['王太利', '肖央'];
        const fenghuang = ['曾毅', '玲花'];
        // 传统的合并方式
        // const zuixuanxiaopingguo = kuaizi.concat(fenghuang);
        const zuixuanxiaopingguo = [...kuaizi, ...fenghuang];
        console.log(zuixuanxiaopingguo);
        //2. 数组的克隆
        const sanzhihua = ['E', 'G', 'M'];
        const sanyecao = [...sanzhihua];// ['E','G','M']
        console.log(sanyecao);
        //3. 将伪数组转为真正的数组
        const divs = document.querySelectorAll('div');
        const divArr = [...divs];
        console.log(divArr); // arguments
    </script>
</body>
</html>
```

